<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta property="og:site_name" content="Motoopen">
<title>Thu√™ Xe M√°y H√† N·ªôi | Motoopen</title>

<style>
:root {
  --accent: #007aff;
  --bg-light: #ffffff;
  --bg-dark: #1C1C1E;
  --text-light: #1d1d1f;
  --text-dark: #f2f2f7;
}
body {
  font-family: 'Inter', system-ui, sans-serif;
  background: var(--bg-light);
  color: var(--text-light);
  margin: 0;
  padding: 0;
  transition: background 0.3s, color 0.3s;
}
body.dark {
  background: var(--bg-dark);
  color: var(--text-dark);
}

/* Demo content */
main {
  padding: 60px 20px;
  text-align: center;
}
main h1 { color: var(--accent); }

/* === MotoAI Styles === */
#motoai-fab {
  position: fixed;
  bottom: 90px;
  left: 20px;
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background: var(--accent);
  color: #fff;
  border: none;
  cursor: pointer;
  box-shadow: 0 6px 20px rgba(0,0,0,0.2);
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 1.6rem;
  z-index: 9999;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}
#motoai-fab:hover {
  transform: scale(1.1);
  box-shadow: 0 8px 26px rgba(0,122,255,0.4);
}

#motoai-box {
  position: fixed;
  bottom: 160px;
  left: 20px;
  width: 320px;
  max-height: 420px;
  background: var(--bg-light);
  color: var(--text-light);
  border-radius: 14px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.2);
  display: none;
  flex-direction: column;
  overflow: hidden;
  transition: background 0.3s, color 0.3s;
  z-index: 9999;
}
body.dark #motoai-box {
  background: var(--bg-dark);
  color: var(--text-dark);
}

#motoai-header {
  background: var(--accent);
  color: #fff;
  padding: 10px 12px;
  font-weight: 600;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
#motoai-content {
  padding: 12px;
  flex: 1;
  overflow-y: auto;
  font-size: 0.95rem;
}
#motoai-input {
  display: flex;
  border-top: 1px solid rgba(0,0,0,0.1);
}
#motoai-input input {
  flex: 1;
  border: none;
  padding: 10px;
  font-size: 0.9rem;
  outline: none;
  background: transparent;
  color: inherit;
}
#motoai-input button {
  background: var(--accent);
  color: #fff;
  border: none;
  padding: 10px 14px;
  cursor: pointer;
}
.moto-msg {
  margin-bottom: 8px;
  line-height: 1.4;
}
.moto-user { text-align: right; color: var(--accent); font-weight: 600; }
.moto-bot { text-align: left; }
.moto-typing {
  font-style: italic; color: gray; animation: blink 1s steps(2, start) infinite;
}
@keyframes blink { to { visibility: hidden; } }
</style>
</head>
<body>
<main>
  <h1>üöÄ Demo MotoAI Assistant v1.8</h1>
  <p>M·ªü g√≥c tr√°i b√™n d∆∞·ªõi ƒë·ªÉ th·ª≠ chatbot t·ª± ƒë·ªông nh·∫≠n di·ªán website.</p>
</main>

<!-- Motoopen AI v2.0 ‚Äî iOS Mini-App Experience (drag anywhere, keep position) -->
<script>
(function(){
  /* ---------------------------
     Motoopen AI v2.0
     - draggable bubble + draggable panel (free)
     - open animation from bubble (scale/translate)
     - frosted glass, dark mode, accent inherit
     - retrieval from HTML/meta/JSON-LD (client-side)
     - quick suggestions, typing animation, session memory
     - remembers last positions (localStorage)
     - use MotoAI.setServer({ aiEndpoint }) to enable remote
  ---------------------------*/

  const STORAGE_KEY = 'motoai_v2_state';
  const MEM_KEY = 'motoai_v2_mem';
  const STATE = {
    config: { aiEndpoint: null, maxSnippets: 10, memorySize: 6, minScore: 0.04 },
    corpus: [],
    memory: []
  };

  // --- Utilities ---
  function qs(sel, root=document) { return root.querySelector(sel); }
  function qsa(sel, root=document) { return Array.from(root.querySelectorAll(sel)); }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  // --- Extract site text & corpus ---
  function extractCorpus(){
    try {
      const texts=[];
      const walker=document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
      while(walker.nextNode()){
        const t = walker.currentNode.nodeValue.trim();
        if(t.length > 30) texts.push(t.replace(/\s+/g,' '));
      }
      const metas = Array.from(document.querySelectorAll('meta[name],meta[property]'))
        .map(m => (m.getAttribute('name')||m.getAttribute('property')) + ': ' + (m.content||''))
        .filter(Boolean);
      const jsonld = Array.from(document.querySelectorAll('script[type="application/ld+json"]'))
        .map(s => s.textContent || '').filter(Boolean);
      const all = [document.title || '', ...metas, ...texts, ...jsonld].join(' ');
      const sentences = all.replace(/\s+/g,' ').split(/(?<=[.?!])\s+(?=[A-Z√Ä-·ª¥0-9"'])/).filter(s=>s.length>20);
      STATE.corpus = sentences;
    } catch(e) {
      console.warn('MotoAI v2 extract error', e);
      STATE.corpus = [];
    }
  }

  // --- Simple trigram embed & similarity ---
  function embed(text){
    const m = new Map(); if(!text) return m;
    const s = text.toLowerCase();
    const n = 3;
    for(let i=0;i<=s.length-n;i++){ const g = s.slice(i,i+n); m.set(g,(m.get(g)||0)+1); }
    return m;
  }
  function sim(a,b){
    const ks = new Set([...a.keys(), ...b.keys()]);
    let dot=0, na=0, nb=0;
    for(const k of ks){ const va=a.get(k)||0, vb=b.get(k)||0; dot += va*vb; na += va*va; nb += vb*vb; }
    return dot / (Math.sqrt(na)*Math.sqrt(nb) + 1e-12);
  }
  function retrieve(query){
    const qv = embed(query);
    const scored = STATE.corpus.map(s => ({ text: s, score: sim(qv, embed(s)) }));
    scored.sort((a,b)=>b.score - a.score);
    return scored.slice(0, STATE.config.maxSnippets);
  }

  // --- Memory storage ---
  function loadMemory(){ try{ STATE.memory = JSON.parse(sessionStorage.getItem(MEM_KEY) || '[]'); }catch{ STATE.memory = []; } }
  function saveMemory(){ try{ sessionStorage.setItem(MEM_KEY, JSON.stringify(STATE.memory)); }catch{} }
  function pushMemory(role, text){ STATE.memory.push({ role, text, ts: Date.now() }); const cap = STATE.config.memorySize*2; if(STATE.memory.length>cap) STATE.memory = STATE.memory.slice(-cap); saveMemory(); }

  // --- Site name & accent detection ---
  function detectSiteName(){
    return (document.querySelector('meta[property="og:site_name"]')?.content ||
            document.querySelector('meta[name="application-name"]')?.content ||
            document.title?.split('|')[0]?.trim() ||
            'website n√†y');
  }
  function inheritAccent(){
    const root = getComputedStyle(document.documentElement);
    const cand = root.getPropertyValue('--accent') || root.getPropertyValue('--primary') || root.getPropertyValue('--accent-color') || '';
    if(cand && cand.trim()) document.documentElement.style.setProperty('--motoai-accent', cand.trim());
    else document.documentElement.style.setProperty('--motoai-accent', '#007aff');
  }

  // --- Answer generation (local extractive fallback; supports remote) ---
  async function generateAnswer(query){
    const cand = retrieve(query);
    if(!cand.length || cand[0].score < STATE.config.minScore){
      return "Hmm... m√¨nh ch∆∞a t√¨m th·∫•y th√¥ng tin r√µ r√†ng tr√™n trang ü§î. B·∫°n th·ª≠ h·ªèi chi ti·∫øt h∆°n, ho·∫∑c li√™n h·ªá Zalo/SDT ƒë·ªÉ Motoopen h·ªó tr·ª£ nh√©!";
    }
    const context = cand.map(c=>c.text).join(' ');
    if(STATE.config.aiEndpoint){
      try{
        const payload = { prompt: query, context, memory: STATE.memory.slice(-STATE.config.memorySize) };
        const res = await fetch(STATE.config.aiEndpoint, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        if(res.ok){
          const j = await res.json();
          return j.answer || j.output || JSON.stringify(j);
        }
      }catch(e){ console.warn('MotoAI remote error', e); }
    }
    // local extractive ranking by overlap words
    const qWords = query.toLowerCase().split(/\W+/).filter(Boolean);
    const sentences = context.split(/(?<=[.?!])\s+/);
    const scored = sentences.map(s=>{
      const lw = s.toLowerCase();
      const overlap = qWords.filter(w => lw.includes(w)).length;
      return { s, overlap };
    }).sort((a,b)=>b.overlap - a.overlap);
    const best = scored.slice(0,3).map(x=>x.s).join(' ');
    if(best && best.length>10) return best.slice(0, 800);
    return "M√¨nh h∆°i m∆° h·ªì v·ªÅ ƒëi·ªÅu n√†y ü§î. B·∫°n th·ª≠ h·ªèi l·∫°i c·ª• th·ªÉ h∆°n, ho·∫∑c g·ªçi 0857 255 868 (Zalo) ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ nhanh nh√©!";
  }

  // --- UI Construction & behavior (draggable/floating, open animation) ---
  function buildUI(){
    // ensure root
    let root = document.getElementById('motoai-root');
    if(!root){ root = document.createElement('div'); root.id = 'motoai-root'; document.body.appendChild(root); }
    root.innerHTML = '';

    inheritAccent();
    const site = detectSiteName();
    loadMemory();

    // CSS (scoped by id selectors to avoid conflicts)
    const STYLE = `
      :root{ --m-ai-accent: var(--motoai-accent, #007aff); }
      #motoai-root { position: fixed; left: 18px; bottom: 90px; z-index: 2147483000; pointer-events: none; }
      /* bubble */
      #motoai-bubble {
        pointer-events: auto;
        width:64px;height:64px;border-radius:20px;background:var(--m-ai-accent);
        color:#fff;display:flex;align-items:center;justify-content:center;font-size:24px;cursor:grab;
        box-shadow: 0 12px 36px rgba(0,0,0,0.18); border:1px solid rgba(255,255,255,0.06);
        transition: transform .18s ease;
        -webkit-user-select:none; user-select:none;
      }
      #motoai-bubble:active{ cursor:grabbing; transform: scale(.98) }
      /* panel (floating card) */
      #motoai-panel {
        pointer-events: auto;
        position: fixed; left: 18px; bottom: 170px; width: 380px; max-height: 620px;
        border-radius: 16px; overflow: hidden;
        background: rgba(255,255,255,0.75); backdrop-filter: blur(8px) saturate(120%);
        box-shadow: 0 18px 48px rgba(0,0,0,0.25); border: 1px solid rgba(0,0,0,0.06);
        transform-origin: center center;
        opacity: 0; transform: scale(.92) translateY(12px);
        transition: transform .32s cubic-bezier(.2,.9,.2,1), opacity .26s ease;
      }
      @media (prefers-color-scheme: dark){
        #motoai-panel { background: rgba(16,16,18,0.55); border: 1px solid rgba(255,255,255,0.04); }
      }
      #motoai-panel.open { opacity: 1; transform: scale(1) translateY(0); }
      /* header (drag handle) */
      #motoai-header {
        display:flex;align-items:center;justify-content:space-between;padding:12px 14px;
        background: linear-gradient(90deg, var(--m-ai-accent), color-mix(in srgb, var(--m-ai-accent) 60%, #00d4ff));
        color: #fff; font-weight:700; cursor:grab;
      }
      #motoai-header:active{ cursor:grabbing; }
      #motoai-body { padding:12px; overflow:auto; max-height:420px; background: transparent; color: inherit; }
      #motoai-input { display:flex; gap:8px; padding:10px; border-top:1px solid rgba(0,0,0,0.06); background: rgba(255,255,255,0.02); }
      #motoai-input input { flex:1; padding:10px 12px; border-radius:10px; border:1px solid rgba(0,0,0,0.06); outline:none; background:transparent; color:inherit; }
      #motoai-input button { background:var(--m-ai-accent); color:#fff; border: none; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:700; }
      .m-msg { margin:8px 0; padding:10px 12px; border-radius:12px; max-width:86%; font-size:0.95rem; line-height:1.38; box-shadow: 0 6px 18px rgba(0,0,0,0.06); }
      .m-msg.user { margin-left:auto; background: linear-gradient(180deg, var(--m-ai-accent), color-mix(in srgb, var(--m-ai-accent) 60%, #00d4ff)); color:#fff; border-bottom-right-radius:6px; }
      .m-msg.bot { margin-right:auto; background: color-mix(in srgb, rgba(255,255,255,0.96), black 6%); color:inherit; border-bottom-left-radius:6px; }
      @media (prefers-color-scheme: dark){ .m-msg.bot { background: rgba(255,255,255,0.04); } }
      .m-typing{ font-style:italic; color: #888; }
      .m-quick { display:flex; gap:8px; padding:10px; flex-wrap:wrap; border-top:1px solid rgba(0,0,0,0.04); background:transparent; }
      .m-quick button { background:transparent; border:1px solid rgba(0,0,0,0.06); padding:8px 12px; border-radius:999px; cursor:pointer; color:var(--m-ai-accent); font-weight:600; }
      @media (prefers-color-scheme: dark){ .m-quick button { border-color: rgba(255,255,255,0.06); } }
      .m-footer{ padding:8px 12px; font-size:12px; color:rgba(0,0,0,0.55); text-align:center; }
      @media (prefers-color-scheme: dark){ .m-footer { color: rgba(255,255,255,0.6); } }
      /* responsive */
      @media(max-width:420px){ #motoai-panel { width: calc(100% - 28px); left:14px; right:14px; bottom:120px; } }
    `;

    // append CSS + HTML
    const styleNode = document.createElement('style'); styleNode.textContent = STYLE;
    root.appendChild(styleNode);

    const bubble = document.createElement('div');
    bubble.id = 'motoai-bubble';
    bubble.setAttribute('role','button');
    bubble.title = `${site} AI`;
    bubble.innerHTML = `<svg width="22" height="22" viewBox="0 0 24 24" fill="none" aria-hidden><path d="M21 15a2 2 0 0 1-2 2H8l-5 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10z" fill="currentColor"/></svg>`;

    const panel = document.createElement('div'); panel.id = 'motoai-panel';
    panel.innerHTML = `
      <div id="motoai-header" aria-label="Motoopen AI header">
        <div style="display:flex;gap:10px;align-items:center">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden><path d="M12 2a10 10 0 100 20 10 10 0 000-20z" fill="currentColor"/></svg>
          <div><strong>${site} AI</strong></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="motoai-min" title="Thu nh·ªè" style="background:transparent;border:none;color:rgba(255,255,255,0.95);cursor:pointer">‚Äî</button>
          <button id="motoai-close" title="ƒê√≥ng" style="background:transparent;border:none;color:rgba(255,255,255,0.95);cursor:pointer">‚úï</button>
        </div>
      </div>
      <div id="motoai-body" aria-live="polite"></div>
      <div class="m-quick" id="motoai-quick">
        <button data-q="Gi√° thu√™ xe m√°y">Gi√° thu√™</button>
        <button data-q="Lo·∫°i xe c√≥ nh·ªØng g√¨">Lo·∫°i xe</button>
        <button data-q="Giao t·∫≠n n∆°i kh√¥ng">Giao t·∫≠n n∆°i</button>
        <button data-q="Li√™n h·ªá Motoopen">Li√™n h·ªá</button>
      </div>
      <div id="motoai-input">
        <input id="motoai-input-el" type="text" placeholder="Nh·∫≠p c√¢u h·ªèi... (v√≠ d·ª•: Gi√° thu√™ bao nhi√™u?)" aria-label="Nh·∫≠p c√¢u h·ªèi">
        <button id="motoai-send">G·ª≠i</button>
      </div>
      <div class="m-footer">Ho·∫°t ƒë·ªông offline ‚Äî ƒë·ªçc n·ªôi dung trang ‚Ä¢ Zalo/SDT: 0857 255 868</div>
    `;
    root.appendChild(bubble);
    root.appendChild(panel);

    // restore positions from localStorage
    const saved = (()=>{ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}'); }catch{return {}; }})();
    if(saved.bubblePos){ bubble.style.position='fixed'; bubble.style.left = saved.bubblePos.left; bubble.style.top = saved.bubblePos.top; bubble.style.bottom = 'auto'; }
    if(saved.panelPos){ panel.style.position='fixed'; panel.style.left = saved.panelPos.left; panel.style.top = saved.panelPos.top; panel.style.bottom = 'auto'; panel.style.transform = 'scale(1)'; panel.classList.add('open'); bubble.style.display='none'; }

    // references
    const bodyEl = panel.querySelector('#motoai-body');
    const inputEl = panel.querySelector('#motoai-input-el');
    const sendBtn = panel.querySelector('#motoai-send');
    const quick = panel.querySelector('#motoai-quick');
    const closeBtn = panel.querySelector('#motoai-close');
    const minBtn = panel.querySelector('#motoai-min');

    // helper: render memory into body
    function renderMemory(){
      bodyEl.innerHTML = '';
      (STATE.memory || []).slice(-STATE.config.memorySize*2).forEach(m=>{
        const d = document.createElement('div');
        d.className = 'm-msg ' + (m.role==='user' ? 'user' : 'bot');
        d.textContent = m.text;
        bodyEl.appendChild(d);
      });
      bodyEl.scrollTop = bodyEl.scrollHeight;
    }

    // greet when open and no assistant message
    function maybeGreet(){
      const hasAssistant = (STATE.memory||[]).some(m=>m.role==='assistant');
      if(!hasAssistant){
        const greet = `Xin ch√†o üëã! ƒê√¢y l√† ${site} AI ‚Äî tr·ª£ l√Ω ·∫£o c·ªßa trang n√†y. B·∫°n mu·ªën m√¨nh gi√∫p g√¨ n√†o? (v√≠ d·ª•: gi√° thu√™, lo·∫°i xe, ch√≠nh s√°ch giao xe...)`;
        const typingNode = document.createElement('div'); typingNode.className='m-msg bot m-typing'; typingNode.textContent='...';
        bodyEl.appendChild(typingNode); bodyEl.scrollTop = bodyEl.scrollHeight;
        setTimeout(()=>{ typingNode.remove(); const out = document.createElement('div'); out.className='m-msg bot'; bodyEl.appendChild(out); typeReveal(out, greet); pushMemory('assistant', greet); renderMemory(); }, 600);
      }
    }

    // type reveal animation
    function typeReveal(node, text){
      let i=0;
      node.textContent = '';
      function step(){
        const chunk = Math.max(1, Math.floor(Math.random()*6));
        i = Math.min(text.length, i+chunk);
        node.textContent = text.slice(0,i);
        bodyEl.scrollTop = bodyEl.scrollHeight;
        if(i < text.length) requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    // ask flow
    async function ask(q){
      if(!q || !q.trim()) return;
      pushMemory('user', q);
      renderMemory();
      inputEl.value = '';
      // show typing
      const tnode = document.createElement('div'); tnode.className = 'm-msg bot m-typing'; tnode.textContent = 'ƒêang g√µ‚Ä¶';
      bodyEl.appendChild(tnode); bodyEl.scrollTop = bodyEl.scrollHeight;
      try{
        const ans = await generateAnswer(q);
        tnode.remove();
        const out = document.createElement('div'); out.className = 'm-msg bot'; bodyEl.appendChild(out);
        typeReveal(out, ans);
        pushMemory('assistant', ans);
        renderMemory();
      }catch(e){
        tnode.remove();
        const err = 'Xin l·ªói, c√≥ l·ªói khi x·ª≠ l√Ω. Th·ª≠ l·∫°i nh√©.';
        const out = document.createElement('div'); out.className='m-msg bot'; out.textContent = err;
        bodyEl.appendChild(out); pushMemory('assistant', err); renderMemory();
        console.error(e);
      }
    }

    // push memory helper
    function pushMemory(role, text){ STATE.memory.push({ role, text, ts: Date.now() }); const cap = STATE.config.memorySize*2; if(STATE.memory.length>cap) STATE.memory = STATE.memory.slice(-cap); saveMemory(); }

    // quick buttons
    qsa('.m-quick button', panel).forEach(btn=>{
      btn.addEventListener('click', ()=>{ const q = btn.dataset.q; ask(q); });
    });

    // events: opening, closing
    bubble.addEventListener('click', (e)=>{
      // animate from bubble position to panel open
      openPanelFromBubble();
    });

    closeBtn.addEventListener('click', ()=>{
      closePanel();
    });

    minBtn.addEventListener('click', ()=>{
      // toggle quick suggestions collapse
      quick.style.display = (quick.style.display === 'none') ? 'flex' : 'none';
    });

    sendBtn.addEventListener('click', ()=> ask(inputEl.value));
    inputEl.addEventListener('keydown', e => { if(e.key === 'Enter') ask(inputEl.value); });

    // restore previous visual content if available
    try{ const prevHtml = sessionStorage.getItem('motoai_v2_html'); if(prevHtml) bodyEl.innerHTML = prevHtml; }catch{}

    // autosave content
    window.addEventListener('beforeunload', ()=> { try{ sessionStorage.setItem('motoai_v2_html', bodyEl.innerHTML); }catch{} });

    // render memory initially
    renderMemory();

    // maybe greet if panel is open or when opened
    function openPanelFromBubble(){
      // hide bubble during open
      bubble.style.display = 'none';
      // position panel at bubble position
      const bRect = bubble.getBoundingClientRect();
      panel.style.left = (bRect.left) + 'px';
      panel.style.top = (bRect.top - (panel.offsetHeight || 360)) + 'px';
      panel.style.bottom = 'auto';
      panel.classList.add('open');
      panel.style.opacity = '0'; panel.style.transform = 'scale(.94) translateY(12px)';
      // animate to final (we'll center full transform)
      requestAnimationFrame(()=>{
        panel.style.opacity = '1'; panel.style.transform = 'scale(1) translateY(0)';
      });
      panel.setAttribute('aria-hidden','false');
      // save positions
      savePositions();
      // render & greet
      renderMemory();
      maybeGreet();
      inputEl.focus();
      // enable dragging panel (user may move)
      enableDrag(panel, true);
    }

    function closePanel(){
      panel.classList.remove('open');
      panel.setAttribute('aria-hidden','true');
      // show bubble back
      bubble.style.display = 'flex';
      // save positions
      savePositions();
    }

    // --- Dragging behavior (free) for bubble and panel ---
    // store positions as { bubblePos: {left,top}, panelPos: {left,top} }
    function savePositions(){
      try{
        const state = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
        // bubble
        const bRect = bubble.getBoundingClientRect();
        if(bRect){
          state.bubblePos = { left: `${bRect.left}px`, top: `${bRect.top}px` };
        }
        // panel (if visible or positioned)
        const pRect = panel.getBoundingClientRect();
        if(pRect){
          state.panelPos = { left: `${pRect.left}px`, top: `${pRect.top}px` };
        }
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }catch(e){ console.warn('savePositions', e); }
    }

    function enableDrag(el, movableWhenOpen=false){
      let dragging=false, startX=0, startY=0, origX=0, origY=0, pointerId=null;
      const onPointerDown = (ev) => {
        // left mouse only or touch
        ev.preventDefault();
        dragging = true;
        pointerId = ev.pointerId || null;
        startX = ev.clientX;
        startY = ev.clientY;
        const rect = el.getBoundingClientRect();
        origX = rect.left;
        origY = rect.top;
        el.setPointerCapture && el.setPointerCapture(pointerId);
        el.style.transition = 'none';
      };
      const onPointerMove = (ev) => {
        if(!dragging) return;
        const dx = ev.clientX - startX;
        const dy = ev.clientY - startY;
        const newLeft = clamp(origX + dx, 8, window.innerWidth - el.offsetWidth - 8);
        const newTop = clamp(origY + dy, 8, window.innerHeight - el.offsetHeight - 8);
        el.style.left = newLeft + 'px';
        el.style.top = newTop + 'px';
        el.style.bottom = 'auto';
      };
      const onPointerUp = (ev) => {
        if(!dragging) return;
        dragging = false;
        el.releasePointerCapture && el.releasePointerCapture(pointerId);
        el.style.transition = '';
        savePositions();
      };
      // attach events
      el.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      // also allow touch/mouse fallback
    }

    // make bubble draggable
    // position bubble absolute in fixed context
    (function initBubbleDrag(){
      // set initial styles to allow left/top
      bubble.style.position = 'fixed';
      bubble.style.left = saved?.bubblePos?.left || bubble.style.left || '18px';
      bubble.style.top = saved?.bubblePos?.top || bubble.style.top || '';
      if(!bubble.style.top) bubble.style.bottom = '90px';
      // attach drag
      enableDrag(bubble, false);
    })();

    // make panel draggable via header
    (function initPanelDrag(){
      const header = panel.querySelector('#motoai-header');
      header.style.cursor = 'grab';
      header.addEventListener('pointerdown', (e)=>{ header.setPointerCapture && header.setPointerCapture(e.pointerId); }, { passive:false });
      enableDrag(panel, true);
    })();

    // expose API
    window.MotoAI = {
      setServer: ({ aiEndpoint }) => { STATE.config.aiEndpoint = aiEndpoint; console.log('MotoAI endpoint set', aiEndpoint); },
      ask: (q) => { return (async()=>{ await ask(q); })(); },
      _state: STATE
    };

    // finish build
  } // end buildUI

  // initialize
  try{ extractCorpus(); }catch(e){ console.warn('extract failed', e); }
  if(!document.getElementById('motoai-root')){
    const r = document.createElement('div'); r.id = 'motoai-root'; document.body.appendChild(r);
  }
  buildUI();

  // done
  console.log('Motoopen AI v2.0 initialized ‚Äî drag the bubble anywhere, click to open mini-app.');

})();
</script>
</body>
</html>
